# 크리스마스 프로모션

## 핵심 기능
* 주문을 받아 금액을 계산한다.
  1. 메뉴 구현
  2. 계산 로직 구현
  3. 입출력 로직 구현

## 구현 기능 목록

## 요구 사항
### 사전 기능 정리
* 방문 날짜에 따른 이벤트가 적용되었는가
* 메뉴와 정가가 맞게 책정되었는가
* 주문 메뉴에 따라 할인 전 총주문 금액을 계산하였는가
* 총주문 금액에 따라 증정 메뉴가 고려되었는가
* 이벤트와 증정 메뉴를 고려하여 혜택이 올바르게 계산되었는가
* 총혜택 금액에 따라 알맞은 이벤트 배지가 부여되었는가

### 프로그래밍 요구 사항
* indent depth 유지
* 3항 연산자 쓰지 않기
* 길이 유지하기
* else 쓰지 않기
* 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다
* InputView, OutputView 클래스를 참고하여 입출력 클래스르 구현
  * 입력과 출력을 담당하는 클래스를 별도로 구현

## 공통 피드백
* main()함수를 포함하여 함수를 15라인 이하로 유지
* 예외 상황에 대한 고민
* 비즈니스 로직과 UI 로직을 분리
* 연관성이 있는 상수는 static final 대신 enum을 활용
  * 애피타이저, 메인, 디저트, 음료를 enum으로 만들면 좋을 것 같다
* final 키워드를 사용해 값의 변경을 막는다
* 객체의 상태 접근을 제한한다 - 인스턴스 변수의 접근 제어자는 private으로 구현
* 객체는 객체스럽게 사용한다 - 데이터를 가지는 객체가 일하도록 한다
* 필드(인스턴스 변수)의 수를 줄이기 위해 노력한다
* 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다
* 테스트 코드도 코드다 - 특히 반복적으로 하는 부분을 중복되지 않게 만들어야 한다
  * @ValueSource 알아보기
* 테스트를 위한 코드는 구현 코드에서 분리되어야 한다
* 단위 테스트하기 어려운 코드를 단위 테스트하기 - 테스트하기 어려운 부분은 분리하고 테스트 가능한 부분을 단위 테스트한다
* private 함수를 테스트하고 싶다면 클래스(객체) 분리를 고려한다 - 가독성 이상의 역할을 하는 경우, 테스트하기 쉽게 구현하기 위해서는 해당 역할을 수행하는 다른 객체를 만들 타이밍이 아닐지 고민해 볼 수 있다